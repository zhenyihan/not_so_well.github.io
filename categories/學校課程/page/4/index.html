<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Category: 學校課程 | Morris&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Morris' Blog">
<meta property="og:url" content="http://morris821028.github.io/categories/學校課程/page/4/index.html">
<meta property="og:site_name" content="Morris' Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Morris' Blog">
<meta name="twitter:description">
<link rel="publisher" href="108158678174364350000">
  
    <link rel="alternative" href="/atom.xml" title="Morris&#39; Blog" type="application/atom+xml">
  
  
    <meta name="google-site-verification" content="5mRgj8NanEMpGZuNfHNJNmH90RgNlrnJXsFlTaKD6Gs" />
  
  
    <link rel="shortcut icon" href="/img/f.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <script src="/js/jquery-2.1.0.min.js"></script>
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="http://cdn.oesmith.co.uk/morris-0.5.1.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js"></script>
<script src="http://cdn.oesmith.co.uk/morris-0.5.1.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"><div id="banner-right"></div></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Morris&#39; Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          
            <a class="main-nav-link" href="/"><i class=icon-home title='Home'></i></a>
          
        
          
            <a class="main-nav-link" href="/about"><i class=icon-user title='About'></i></a>
          
        
          
            <a class="main-nav-link" href="/archives"><i class=icon-archive title='Archives'></i></a>
          
        
          
            <a class="main-nav-link" href="/tags"><i class=icon-tags title='Tags'></i></a>
          
        
          
            <a class="main-nav-link" href="/picture"><i class=icon-camera title='Pictures'></i></a>
          
        
          
            <a class="main-nav-link" href="/works"><i class=icon-trophy title='Works'></i></a>
          
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://morris821028.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        
          <section id="main">
  
    <article id="post-jg-10026" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/30/jg-10026/" class="article-date">
  <time datetime="2016-04-30T02:48:28.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/jg-10026/">批改娘 10026. Fast N-Queen</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/04/30/jg-10026/" data-id="ciq8w9649003l9yxc9a1l3p97" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/04/30/jg-10026/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenMP/">OpenMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/負載平衡/">負載平衡</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>相信 n-Queen 問題對每個研究 backtracking 的人來講都不陌生，這個問題是要在一個 $n \times n$ 大小的棋盤上擺n個皇后，讓她們不會互相攻擊到。為了讓這個問題更難一點，我們設計了一些障礙物在棋盤上，在這些點上不能放皇后。請留意這些障礙物並不會防止皇后被攻擊。 </p>
<p>在傳統的 8-Queen 問題中，旋轉與鏡射被視為不同解法，因此我們有 92 種可能的方式來放置皇后。 </p>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>輸入的資料最多包含 10 筆測試個案，每個測試個案的第一行會有一個整數 $n$ ($3 &lt; n &lt; 20$)，接下來的 $n$ 行代表棋盤資料，點號 <code>&#39;.&#39;</code> 代表空的盤格，星號 <code>&#39;*&#39;</code> 代表放有障礙物的盤格。</p>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>對每筆測試個案，輸出這是第幾個 case 以及這個 case 有幾種可能的放置方式。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">4</span><br><span class="line">.*..</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 92</span><br><span class="line">Case 2: 1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，必須先認識最快的 N 皇后問題可以利用 bitmask 的技術，把過多的 memory access 的指令捨去而加速。</p>
<ul>
<li>樸素平行 Accepted (2766 ms, 512 KB)</li>
<li>負載平衡 Accepted (1771 ms, 5248 KB)</li>
</ul>
<h3 id="樸素平行"><a href="#樸素平行" class="headerlink" title="樸素平行"></a>樸素平行</h3><p>在大多數的教科書上，平行只針對第一個列的位置平行，因此平行度最多 $N$，針對第一列每一個位置都分別開一個 thread 找解，這樣運算時間相當於跑最慢的那一個 thread。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> y_valid[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> lv, <span class="keyword">int</span> row, <span class="keyword">int</span> dia1, <span class="keyword">int</span> dia2, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == mask)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = mask &amp; (~(row | dia1 | dia2)) &amp; y_valid[lv], p;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        p = pos &amp; (-pos);</span><br><span class="line">        pos -= p;</span><br><span class="line">        ret += dfs(lv+<span class="number">1</span>, row|p, (dia1|p)&lt;&lt;<span class="number">1</span>, (dia2|p)&gt;&gt;<span class="number">1</span>, mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> chunk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, dia1 = <span class="number">0</span>, dia2 = <span class="number">0</span>, mask = (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>, lv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = mask &amp; (~(row | dia1 | dia2)) &amp; y_valid[<span class="number">0</span>], p;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic, chunk) reduction(+:sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pos&gt;&gt;i)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            p = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">int</span> t = dfs(lv+<span class="number">1</span>, row|p, (dia1|p)&lt;&lt;<span class="number">1</span>, (dia2|p)&gt;&gt;<span class="number">1</span>, mask);</span><br><span class="line">            sum += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>, n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            y_valid[i] = (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">'*'</span>)</span><br><span class="line">                    y_valid[i] ^= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = totalNQueens(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cases, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="負載平衡"><a href="#負載平衡" class="headerlink" title="負載平衡"></a>負載平衡</h3><p>為了達到每一個 thread 盡可能分到相同的工作量，避免最慘的那一條有太多的解而很慢，做好細粒度 (fine-grain) 的分配，如此一來工作量就很高的機率會相同。</p>
<p>因此，一開始先進行廣度搜索，把前幾列的解展開，也許會獲得 $N^x$ 種盤面，這時候平均切給 $M$ 條 thread，分配的工作量平衡上就有比較好的展現。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 16384</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 32</span></span><br><span class="line"><span class="keyword">int</span> y_valid[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Board &#123;</span><br><span class="line">    <span class="keyword">int</span> row, dia1, dia2;</span><br><span class="line">&#125; Board;</span><br><span class="line">Board R[MAXQ*MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> lv, <span class="keyword">int</span> row, <span class="keyword">int</span> dia1, <span class="keyword">int</span> dia2, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == mask)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = mask &amp; (~(row | dia1 | dia2)) &amp; y_valid[lv], p;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        p = pos &amp; (-pos);</span><br><span class="line">        pos -= p;</span><br><span class="line">        ret += dfs(lv+<span class="number">1</span>, row|p, (dia1|p)&lt;&lt;<span class="number">1</span>, (dia2|p)&gt;&gt;<span class="number">1</span>, mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ida_dep, ida_cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDA</span><span class="params">(<span class="keyword">int</span> lv, <span class="keyword">int</span> row, <span class="keyword">int</span> dia1, <span class="keyword">int</span> dia2, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lv == ida_dep) &#123;</span><br><span class="line">        Board b = &#123;.row = row, .dia1 = dia1, .dia2 = dia2&#125;;</span><br><span class="line">        R[ida_cnt++] = b;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos = mask &amp; (~(row | dia1 | dia2)) &amp; y_valid[lv], p;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        p = pos &amp; (-pos);</span><br><span class="line">        pos -= p;</span><br><span class="line">        IDA(lv+<span class="number">1</span>, row|p, (dia1|p)&lt;&lt;<span class="number">1</span>, (dia2|p)&gt;&gt;<span class="number">1</span>, mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> it = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, dia1 = <span class="number">0</span>, dia2 = <span class="number">0</span>, mask = (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>, lv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (it = <span class="number">1</span>; it &lt;= n; it++) &#123;</span><br><span class="line">        ida_dep = it, ida_cnt = <span class="number">0</span>;</span><br><span class="line">        IDA(<span class="number">0</span>, row, dia1, dia2, mask);</span><br><span class="line">        <span class="keyword">if</span> (ida_cnt &gt;= MAXQ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> chunk = <span class="number">1024</span>;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static, chunk) reduction(+:sum)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ida_cnt; i++)</span><br><span class="line">                sum += dfs(it, R[i].row, R[i].dia1, R[i].dia2, mask);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ida_cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>, n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">32</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            y_valid[i] = (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">'*'</span>)</span><br><span class="line">                    y_valid[i] ^= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = totalNQueens(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cases, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-jg-10025" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/30/jg-10025/" class="article-date">
  <time datetime="2016-04-30T02:36:39.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/jg-10025/">批改娘 10025. Fast Image Match (OpenMP)</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/04/30/jg-10025/" data-id="ciq8w964j003o9yxczdl31wi5" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/04/30/jg-10025/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FFT/">FFT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenMP/">OpenMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>圖片匹配和字串匹配有一點不同，字串匹配通常要求其子字串與搜尋字串完全相符，而圖片匹配則用相似度為依據，當圖片大、複雜且具有干擾，或者需要匹配數量非常多，更先進的領域會利用特徵擷取，用機率統計的方式來篩選可能的匹配數量，篩選過後才進行圖片的細節匹配。</p>
<h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>給予兩個圖片 $A, B$，圖片格式為灰階影像，每個像素 $\mathit{pixel}(x, y)$ 採用 8-bits 表示，範圍為 $\mathit{pixel}(x, y) \in [0, 255]$。</p>
<p> 舉一個例子，有一個 $3 \times 3$ 的圖片 $A$ 和一個 $2 \times 2$ 的圖片 $B$，用矩陣表示如下：</p>
<span>$$A := \begin{bmatrix}
a1 &amp; a2 &amp; a3 \\
a4 &amp; a5 &amp; a6 \\
a7 &amp; a8 &amp; a9
\end{bmatrix} ,\; B := \begin{bmatrix}
b1 &amp; b2\\
b3 &amp; b4\\
\end{bmatrix}$$</span><!-- Has MathJax -->
<p>假設左上角座標 $(1, 1)$ 即 $a1$ 的位置、$(1, 2)$ 即 $a2$ 的位置。</p>
<ul>
<li>若把影像 $B$ 左上角對齊 $A$ 的 $(1, 1)$ 位置，其差異程度 $\mathit{diff}(A, B) = (a1 - b1)^2 + (a2 - b2)^2 + (a4 - b3)^2 + (a5 - b4)^2$</li>
<li>相同地，對齊 $(2, 1)$ 位置，其差異程度 $\mathit{diff}(A, B) = (a4 - b1)^2 + (a5 - b2)^2 + (a7 - b3)^2 + (a8 - b4)^2$</li>
</ul>
<p>比較時，整張 $B$ 都要落在 $A$ 中。現在要找到一個對齊位置 $(x, y)$，使得 $\mathit{diff}(A, B)$ 最小。</p>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>多組測資，每一組第一行有四個整數 $A_H, A_W, B_H, B_W$，分別表示圖片 $A$ 的高寬、$B$ 的高寬。</p>
<p>接下來會有 $A_H$ 行，每一行上會有 $A_W$ 個整數，第 $i$ 行上的第 $j$ 個整數 $x$ 表示 $A(i, j)$ 的灰階像素值。同樣地，接下來會有 $B_H$ 行，每一行上會有 $B_W$ 個整數，第 $i$ 行上的第 $j$ 個整數 $x$ 表示 $B(i, j)$ 的灰階像素值。</p>
<ul>
<li>$ 1\le A_H, A_W, B_H, B_W \le 500$</li>
<li>$ B_H \le A_H, B_W \le A_W$</li>
<li>$ 0 \le x \le 255$</li>
</ul>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>對於每一組測資輸出一行，兩個整數 $x, y$，滿足 $\mathit{diff}(A, B)$ 最小。若有相同情況滿足，則優先挑選 $x$ 最小，若 $x$ 仍相同，則挑選 $y$ 最小。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 4 2 2</span><br><span class="line">0 3 3 0</span><br><span class="line">0 3 3 0</span><br><span class="line">0 0 5 5</span><br><span class="line">0 0 5 5</span><br><span class="line">5 5</span><br><span class="line">5 5</span><br><span class="line">3 5 1 2</span><br><span class="line">2 3 0 4 5</span><br><span class="line">0 0 7 0 0</span><br><span class="line">0 0 7 0 0</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="樸素平行"><a href="#樸素平行" class="headerlink" title="樸素平行"></a>樸素平行</h3><p>若圖片是 $N \times N$，樸素算法運作要 $\mathcal{O}(N^4)$，傅立葉算法要 $\mathcal{O}(N^2 \log N)$，這裡針對樸素算法平行。從最高層次的找解平行，每一個匹配位置都要耗費 $\mathcal{O}(M^2)$ 計算相似性，又由於平行限制跟核心數有關，那麼針對每一個 thread 要求找到好幾個 row 的解，分別存在各自的答案陣列區中，之後再線性跑一次取最小值，利用額外的空間儲存，避免在運算過程中遇到 critical section。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic, chunk) shared(A, B)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Ch; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Cw; j++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; Bh; p++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; Bw; q++) &#123;</span><br><span class="line">                d += (<span class="keyword">long</span> <span class="keyword">long</span>) (B[p][q] - A[i+p][j+q])*(B[p][q] - A[i+p][j+q]);</span><br><span class="line">            &#125;                   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; diff)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line">            <span class="keyword">if</span> (d &lt; diff)</span><br><span class="line">                diff = d, bx = i, by = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是上列的寫法會卡在 critical section，倒不如存在另一個陣列中，效能還差距個幾百毫秒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 512</span></span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], B[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Ah, Aw, Bh, Bw, x;</span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;Ah, &amp;Aw, &amp;Bh, &amp;Bw) == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Ah; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Aw; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), A[i][j] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Bh; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Bw; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), B[i][j] = x;</span><br><span class="line">        <span class="keyword">int</span> Ch = Ah - Bh, Cw = Aw - Bw;</span><br><span class="line">        <span class="keyword">int</span> bx = <span class="number">-1</span>, by = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Ch; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Cw; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; Bh; p++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; Bw; q++) &#123;</span><br><span class="line">                        d += (B[p][q] - A[i+p][j+q])*(B[p][q] - A[i+p][j+q]);</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">                C[i][j] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Ch; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= Cw; j++)</span><br><span class="line">                <span class="keyword">if</span> (C[i][j] &lt; diff)</span><br><span class="line">                    diff = C[i][j], bx = i, by = j;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, bx + <span class="number">1</span>, by + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p>儘管使用快速傅立葉 (FFT) 已經達到 <span>$\mathcal{O}(N \log N)$</span><!-- Has MathJax --> 的時間複雜度的極致，只比平行樸素算法快個兩到三倍，加入平行之後，效能可以達到五到六倍加速。</p>
<p>FFT 用到大量的三角函數計算，一般而言若使用序列化的乘法代替三角函數計算 (疊加角度) 會比重新計算快上很多，但這樣會損失一大部分的精準度 (但速度快很多)，而且會產生很多相互依賴的指令，這也導致不容易對迴圈平行。</p>
<p>如果需要平行，每一個三角函數可以預先存在陣列中，每一個 thread 直接存取陣列中的元素即可，但麻煩的地方在於最好使用多核處理器，然而跨越多個處理器有可能會因為快取 … 等機制，導致速度下降，因此這裡採用單一處理器六核心 (只有三個是 physical core)，因此 thread 限定在五個以內。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="comment">// FFT header</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 262144</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">&#125; <span class="keyword">complex</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> (* <span class="keyword">const</span> NumberOfBitsNeeded) (<span class="keyword">int</span>);</span><br><span class="line">    UINT32 (* <span class="keyword">const</span> FastReverseBits) (UINT32, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (* <span class="keyword">const</span> FFT) (<span class="keyword">bool</span>, <span class="keyword">complex</span>[], <span class="keyword">complex</span>[], <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (* <span class="keyword">const</span> convolution) (<span class="keyword">double</span> *, <span class="keyword">double</span> *, <span class="keyword">int</span> , <span class="keyword">double</span> *);</span><br><span class="line">&#125; FFT_namespace;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">complex</span> <span class="title">init_complex</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">complex</span> t = &#123;a, b&#125;;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">complex</span> <span class="title">add_complex</span><span class="params">(<span class="keyword">complex</span> *a, <span class="keyword">complex</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> init_complex(a-&gt;x + b-&gt;x, a-&gt;y + b-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">complex</span> <span class="title">sub_complex</span><span class="params">(<span class="keyword">complex</span> *a, <span class="keyword">complex</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> init_complex(a-&gt;x - b-&gt;x, a-&gt;y - b-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">complex</span> <span class="title">mul_complex</span><span class="params">(<span class="keyword">complex</span> *a, <span class="keyword">complex</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> init_complex(a-&gt;x * b-&gt;x - a-&gt;y * b-&gt;y, a-&gt;x * b-&gt;y+ a-&gt;y * b-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">complex</span> pre_theta[<span class="number">2</span>][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> pre_n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (pre_n == n)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    pre_n = n;</span><br><span class="line">    pre_theta[<span class="number">0</span>][<span class="number">0</span>] = init_complex(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    pre_theta[<span class="number">1</span>][<span class="number">0</span>] = init_complex(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre_theta[<span class="number">0</span>][i] = init_complex(<span class="built_in">cos</span>(<span class="number">2</span>*i*PI / n ) , <span class="built_in">sin</span>(<span class="number">2</span>*i*PI / n ));</span><br><span class="line">        pre_theta[<span class="number">1</span>][i] = init_complex(<span class="built_in">cos</span>(<span class="number">2</span>*i*PI / n ) , -<span class="built_in">sin</span>(<span class="number">2</span>*i*PI / n ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FFT body</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfBitsNeeded</span><span class="params">(<span class="keyword">int</span> PowerOfTwo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PowerOfTwo &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT32 <span class="title">FastReverseBits</span><span class="params">(UINT32 a, <span class="keyword">int</span> NumBits)</span> </span>&#123;</span><br><span class="line">    a = ( ( a &amp; <span class="number">0x55555555</span>U ) &lt;&lt; <span class="number">1</span> ) | ( ( a &amp; <span class="number">0xAAAAAAAA</span>U ) &gt;&gt; <span class="number">1</span> ) ;</span><br><span class="line">    a = ( ( a &amp; <span class="number">0x33333333</span>U ) &lt;&lt; <span class="number">2</span> ) | ( ( a &amp; <span class="number">0xCCCCCCCC</span>U ) &gt;&gt; <span class="number">2</span> ) ;</span><br><span class="line">    a = ( ( a &amp; <span class="number">0x0F0F0F0F</span>U ) &lt;&lt; <span class="number">4</span> ) | ( ( a &amp; <span class="number">0xF0F0F0F0</span>U ) &gt;&gt; <span class="number">4</span> ) ;</span><br><span class="line">    a = ( ( a &amp; <span class="number">0x00FF00FF</span>U ) &lt;&lt; <span class="number">8</span> ) | ( ( a &amp; <span class="number">0xFF00FF00</span>U ) &gt;&gt; <span class="number">8</span> ) ;</span><br><span class="line">    a = ( ( a &amp; <span class="number">0x0000FFFF</span>U ) &lt;&lt; <span class="number">16</span> ) | ( ( a &amp; <span class="number">0xFFFF0000</span>U ) &gt;&gt; <span class="number">16</span> ) ;</span><br><span class="line">    <span class="keyword">return</span> a &gt;&gt; (<span class="number">32</span> - NumBits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _FFT(<span class="keyword">bool</span> InverseTransform, <span class="keyword">complex</span> In[], <span class="keyword">complex</span> Out[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// simultaneous data copy and bit-reversal ordering into outputs</span></span><br><span class="line">    <span class="keyword">int</span> NumSamples = n;</span><br><span class="line">    <span class="keyword">int</span> NumBits = NumberOfBitsNeeded(NumSamples);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumSamples; ++i)</span><br><span class="line">        Out[FastReverseBits(i, NumBits)] = In[i];</span><br><span class="line">    <span class="comment">// the FFT process</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= NumBits; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> BlockSize = <span class="number">1</span>&lt;&lt;i, BlockEnd = BlockSize&gt;&gt;<span class="number">1</span>, BlockCnt = NumSamples/BlockSize;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NumSamples; j += BlockSize) &#123;</span><br><span class="line">            <span class="keyword">complex</span> *t = pre_theta[InverseTransform];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; BlockEnd; k++, t += BlockCnt) &#123;</span><br><span class="line">                <span class="keyword">complex</span> a = mul_complex(&amp;(*t), &amp;Out[k+j+BlockEnd]);</span><br><span class="line">                Out[k+j+BlockEnd] = sub_complex(&amp;Out[k+j], &amp;a);</span><br><span class="line">                Out[k+j] = add_complex(&amp;Out[k+j], &amp;a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// normalize if inverse transform</span></span><br><span class="line">    <span class="keyword">if</span> (InverseTransform) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumSamples; ++i) &#123;</span><br><span class="line">            Out[i].x = Out[i].x / NumSamples;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convolution</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">int</span> n, <span class="keyword">double</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">complex</span> s[MAXN], d1[MAXN], d2[MAXN], y[MAXN];</span><br><span class="line">    prework(n);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        s[i] = init_complex(a[i], <span class="number">0</span>);</span><br><span class="line">    _FFT(<span class="literal">false</span>, s, d1, n);</span><br><span class="line">    s[<span class="number">0</span>] = init_complex(b[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        s[i] = init_complex(b[n - i], <span class="number">0</span>);</span><br><span class="line">    _FFT(<span class="literal">false</span>, s, d2, n);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        y[i] = mul_complex(&amp;d1[i], &amp;d2[i]);</span><br><span class="line">    _FFT(<span class="literal">true</span>, y, s, n);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        c[i] = s[i].x;</span><br><span class="line">&#125;</span><br><span class="line">FFT_namespace <span class="keyword">const</span> FFT = &#123;NumberOfBitsNeeded, FastReverseBits, _FFT, convolution&#125;;</span><br><span class="line"><span class="comment">// FFT end</span></span><br><span class="line"><span class="keyword">double</span> a[MAXN], b[MAXN], c[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">512</span>][<span class="number">512</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = sum[rx][ry];</span><br><span class="line">    <span class="keyword">if</span> (lx) ret -= sum[lx<span class="number">-1</span>][ry];</span><br><span class="line">    <span class="keyword">if</span> (ly) ret -= sum[rx][ly<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (lx &amp;&amp; ly)   ret += sum[lx<span class="number">-1</span>][ly<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    omp_set_num_threads(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> m, n, p, q, x, N, M, S;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;m, &amp;n, &amp;p, &amp;q) == <span class="number">4</span>) &#123;</span><br><span class="line">        N = m &gt; p ? m : p, M = n &gt; q ? n : q;</span><br><span class="line">        S = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; S &lt; N*M; S &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) * S);</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b[<span class="number">0</span>]) * S);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                a[i*M+j] = x;</span><br><span class="line">                s += x*x;</span><br><span class="line">                sum[i][j] = (i &gt; <span class="number">0</span> ? sum[i<span class="number">-1</span>][j] : <span class="number">0</span>) + s;          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; q; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                b[i*M+j] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        FFT.convolution(a, b, S, c);</span><br><span class="line">        <span class="keyword">int</span> qx = m - p, qy = n - q, bX = INT_MAX, bY = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> diff = LONG_MAX;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t_diff = LONG_MAX;</span><br><span class="line">            <span class="keyword">int</span> t_bX = INT_MAX, t_bY = INT_MAX;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= qx; i++)    &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= qy; j++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> v = getArea(i, j, i+p<span class="number">-1</span>, j+q<span class="number">-1</span>) - <span class="number">2</span>*c[i*M + j] + <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v &lt; t_diff)</span><br><span class="line">                        t_diff = v, t_bX = i, t_bY = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (t_diff &lt; diff)</span><br><span class="line">                    diff = t_diff, bX = t_bX, bY = t_bY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t_diff == diff &amp;&amp; (t_bX &lt; bX || (t_bX == bX &amp;&amp; t_bY &lt; bY))) &#123;</span><br><span class="line">                    bX = t_bX, bY = t_bY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, bX+<span class="number">1</span>, bY+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-jg-10022" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/20/jg-10022/" class="article-date">
  <time datetime="2016-04-20T05:40:33.000Z" itemprop="datePublished">2016-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/20/jg-10022/">批改娘 10022. Fast Matrix Multiplication</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/04/20/jg-10022/" data-id="ciq8w9643003e9yxcamiuksz6" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/04/20/jg-10022/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenMP/">OpenMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/優化/">優化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/循環展開/">循環展開</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/達夫裝置/">達夫裝置</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="http://i.imgur.com/67stm68.jpg" alt="飼料"></p>
<h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>相信不少人都已經實作所謂的矩陣乘法，計算兩個方陣大小為 <span>$N \times N$</span><!-- Has MathJax --> 的矩陣 <span>$A, B$</span><!-- Has MathJax -->。為了方便起見，提供一個偽隨機數的生成，減少在輸入處理浪費的時間，同時也減少上傳測資的辛苦。</p>
<p>根據種子 <span>$c = S1$</span><!-- Has MathJax --> 生成矩陣 <span>$A$</span><!-- Has MathJax -->，種子 <span>$c = S2$</span><!-- Has MathJax --> 生成矩陣 <span>$B$</span><!-- Has MathJax -->，計算矩陣相乘 <span>$A \times B$</span><!-- Has MathJax -->，為了方便起見，使用 hash 函數進行簽章，最後輸出一個值。由於會牽涉到 overflow 問題，此題作為快取實驗就不考慮這個，overflow 問題都會相同。</p>
<h3 id="matrix-h"><a href="#matrix-h" class="headerlink" title="matrix.h"></a>matrix.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">unsigned</span> <span class="keyword">long</span> A[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> B[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> C[][<span class="number">2048</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="matrix-c"><a href="#matrix-c" class="headerlink" title="matrix.c"></a>matrix.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"matrix.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">unsigned</span> <span class="keyword">long</span> A[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> B[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> C[][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> sum = <span class="number">0</span>;    <span class="comment">// overflow, let it go.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">                sum += A[i][k] * B[k][j];</span><br><span class="line">            C[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"matrix.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT unsigned long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2048</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rand_gen</span><span class="params">(UINT c, <span class="keyword">int</span> N, UINT A[][MAXN])</span> </span>&#123;</span><br><span class="line">    UINT x = <span class="number">2</span>, n = N*N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            x = (x * x + c + i + j)%n;</span><br><span class="line">            A[i][j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">(<span class="keyword">int</span> N, UINT A[][MAXN])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" %u"</span>, A[i][j]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" ]\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT <span class="title">hash</span><span class="params">(UINT x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * <span class="number">2654435761L</span>U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT <span class="title">signature</span><span class="params">(<span class="keyword">int</span> N, UINT A[][MAXN])</span> </span>&#123;</span><br><span class="line">    UINT h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            h = hash(h + A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line">UINT A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, S1, S2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;N, &amp;S1, &amp;S2) == <span class="number">3</span>) &#123;</span><br><span class="line">        rand_gen(S1, N, A);</span><br><span class="line">        rand_gen(S2, N, B);</span><br><span class="line">        multiply(N, A, B, C);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        print_matrix(N, A);</span><br><span class="line">        print_matrix(N, B);</span><br><span class="line">        print_matrix(N, C);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, signature(N, C));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>多組測資，每組測資一行三個整數 <span>$N, S1, S2$</span><!-- Has MathJax -->。</p>
<ul>
<li><span>$1 \le N \le 1000$</span><!-- Has MathJax --></li>
<li><span>$0 \le S1, S2 \le 65536$</span><!-- Has MathJax -->
</li>
</ul>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>每組測資輸出一行，一個整數 signature 的結果。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 2 5</span><br><span class="line">2 2 5</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">573770929</span><br><span class="line">573770929</span><br></pre></td></tr></table></figure>
<h2 id="解釋"><a href="#解釋" class="headerlink" title="解釋"></a>解釋</h2><p>範例輸入產生 <span>$2 \times 2$</span><!-- Has MathJax --> 的矩陣。</p>
<span>$$A = \begin{bmatrix}
2 &amp; 3\\ 
0 &amp; 0
\end{bmatrix}
, B = \begin{bmatrix}
1 &amp; 3\\ 
3 &amp; 0
\end{bmatrix}
, A \times B = \begin{bmatrix}
11 &amp; 6\\ 
0 &amp; 0
\end{bmatrix}$$</span><!-- Has MathJax -->
<h2 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h2><ul>
<li>2016/02/17 加入平行程式設計 OpenMP 部份，並增加時間限制！</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>解法跟 thread 寫法一樣，用 OpenMP 的好處在於不用處理那些 thread 的設定，用 OpenMP 提供的前處理完成執行緒的建造和移除操作。</p>
<p>在這裡特別提供達夫裝置 (Duff’s device) 對於迴圈展開 loop unrolling 的撰寫方式，巧妙地運用 C 語言中的 switch，相比一般寫法需要兩次迴圈處理，最後一個迴圈必須處理剩餘不整除的部分。就實作看起來，在現在版本 4.8 gcc 編譯結果下，效能沒有明顯的差別。</p>
<p>在高等編譯器課程中，聽說迴圈展開的數目最好不是 <span>$2^n$</span><!-- Has MathJax -->，某些情況會造成 alignment 的 cache miss 的嚴重影響，實際情況還是要看怎麼運用，在這裡就不多做嘗試。</p>
<h3 id="matrix-h-1"><a href="#matrix-h-1" class="headerlink" title="matrix.h"></a>matrix.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT unsigned long </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">unsigned</span> <span class="keyword">long</span> A[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> B[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> C[][<span class="number">2048</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="matrix-c-達夫裝置"><a href="#matrix-c-達夫裝置" class="headerlink" title="matrix.c (達夫裝置)"></a>matrix.c (達夫裝置)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"matrix.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_UNROLL 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> N, UINT A[][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    UINT t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">            t = A[i][j], A[i][j] = A[j][i], A[j][i] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, UINT A[][<span class="number">2048</span>], UINT B[][<span class="number">2048</span>], UINT C[][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    transpose(N, B);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">register</span> UINT sum = <span class="number">0</span>;</span><br><span class="line">            UINT *a = &amp;A[i][<span class="number">0</span>], *b = &amp;B[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> k = N;</span><br><span class="line">            <span class="keyword">switch</span> (k % LOOP_UNROLL) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">do</span> &#123; sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: sum += *a * *b, a++, b++;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((k -= LOOP_UNROLL) &gt; <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            C[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="matrix-c-迴圈展開"><a href="#matrix-c-迴圈展開" class="headerlink" title="matrix.c (迴圈展開)"></a>matrix.c (迴圈展開)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"matrix.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_UNROLL 8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose</span><span class="params">(<span class="keyword">int</span> N, UINT A[][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> chunk = <span class="number">8</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic, chunk)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            UINT t;    </span><br><span class="line">            t = A[i][j], A[i][j] = A[j][i], A[j][i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, UINT A[][<span class="number">2048</span>], UINT B[][<span class="number">2048</span>], UINT C[][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    transpose(N, B);</span><br><span class="line">    <span class="keyword">int</span> chunk = <span class="number">8</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic, chunk) shared(C)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">register</span> UINT sum = <span class="number">0</span>;</span><br><span class="line">            UINT *a = &amp;A[i][<span class="number">0</span>], *b = &amp;B[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k+LOOP_UNROLL &lt; N; k += LOOP_UNROLL) &#123;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; k &lt; N; k++)</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">            C[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-jg-10080" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/20/jg-10080/" class="article-date">
  <time datetime="2016-04-20T05:29:42.000Z" itemprop="datePublished">2016-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/20/jg-10080/">批改娘 10080. Fast Matrix Multiplication (pthread)</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/04/20/jg-10080/" data-id="ciq8w964n003t9yxcgpyzrxi8" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/04/20/jg-10080/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>相信不少人都已經實作所謂的矩陣乘法，計算兩個方陣大小為 <span>$N \times N$</span><!-- Has MathJax --> 的矩陣 <span>$A, B$</span><!-- Has MathJax -->。為了方便起見，提供一個偽隨機數的生成，減少在輸入處理浪費的時間，同時也減少上傳測資的辛苦。</p>
<p>根據種子 <span>$c = S1$</span><!-- Has MathJax --> 生成矩陣 <span>$A$</span><!-- Has MathJax -->，種子 <span>$c = S2$</span><!-- Has MathJax --> 生成矩陣 <span>$B$</span><!-- Has MathJax -->，計算矩陣相乘 <span>$A \times B$</span><!-- Has MathJax -->，為了方便起見，使用 hash 函數進行簽章，最後輸出一個值。由於會牽涉到 overflow 問題，此題作為快取實驗就不考慮這個，overflow 問題都會相同。</p>
<h3 id="matrix-h"><a href="#matrix-h" class="headerlink" title="matrix.h"></a>matrix.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">unsigned</span> <span class="keyword">long</span> A[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> B[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> C[][<span class="number">2048</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="matrix-c"><a href="#matrix-c" class="headerlink" title="matrix.c"></a>matrix.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"matrix.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">unsigned</span> <span class="keyword">long</span> A[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> B[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> C[][<span class="number">2048</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> sum = <span class="number">0</span>;    <span class="comment">// overflow, let it go.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">                sum += A[i][k] * B[k][j];</span><br><span class="line">            C[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"matrix.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT unsigned long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2048</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rand_gen</span><span class="params">(UINT c, <span class="keyword">int</span> N, UINT A[][MAXN])</span> </span>&#123;</span><br><span class="line">    UINT x = <span class="number">2</span>, n = N*N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            x = (x * x + c + i + j)%n;</span><br><span class="line">            A[i][j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">(<span class="keyword">int</span> N, UINT A[][MAXN])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" %u"</span>, A[i][j]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" ]\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT <span class="title">hash</span><span class="params">(UINT x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * <span class="number">2654435761L</span>U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">UINT <span class="title">signature</span><span class="params">(<span class="keyword">int</span> N, UINT A[][MAXN])</span> </span>&#123;</span><br><span class="line">    UINT h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            h = hash(h + A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> UINT A[MAXN][MAXN], B[MAXN][MAXN], C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, S1, S2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;N, &amp;S1, &amp;S2) == <span class="number">3</span>) &#123;</span><br><span class="line">        rand_gen(S1, N, A);</span><br><span class="line">        rand_gen(S2, N, B);</span><br><span class="line">        multiply(N, A, B, C);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        print_matrix(N, A);</span><br><span class="line">        print_matrix(N, B);</span><br><span class="line">        print_matrix(N, C);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, signature(N, C));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>多組測資，每組測資一行三個整數 <span>$N, S1, S2$</span><!-- Has MathJax -->。</p>
<ul>
<li><span>$1 \le N \le 1000$</span><!-- Has MathJax --></li>
<li><span>$0 \le S1, S2 \le 65536$</span><!-- Has MathJax -->
</li>
</ul>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>每組測資輸出一行，一個整數 signature 的結果。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 2 5</span><br><span class="line">2 2 5</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">573770929</span><br><span class="line">573770929</span><br></pre></td></tr></table></figure>
<h2 id="解釋"><a href="#解釋" class="headerlink" title="解釋"></a>解釋</h2><p>範例輸入產生 <span>$2 \times 2$</span><!-- Has MathJax --> 的矩陣。</p>
<span>$$A = \begin{bmatrix}
2 &amp; 3\\ 
0 &amp; 0
\end{bmatrix}
, B = \begin{bmatrix}
1 &amp; 3\\ 
3 &amp; 0
\end{bmatrix}
, A \times B = \begin{bmatrix}
11 &amp; 6\\ 
0 &amp; 0
\end{bmatrix}$$</span><!-- Has MathJax -->
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix.out: matrix.h matrix.c main.c</span><br><span class="line">    gcc -std=c99 -O2 matrix.h matrix.c main.c -o matrix -lpthread -lm</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>針對矩陣乘法平行很簡單，在 CPU 上由於需要搬運資料，不一定開的 thread 數量接近 core 數量就一定最好。而在平行的部分要把握資料局部性的加速，以下實作根據最終答案進行 row-based 策略切割，每一個 thread 計算那一個 row 的所有答案。</p>
<h3 id="matrix-h-1"><a href="#matrix-h-1" class="headerlink" title="matrix.h"></a>matrix.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT unsigned long </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">unsigned</span> <span class="keyword">long</span> A[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> B[][<span class="number">2048</span>], <span class="keyword">unsigned</span> <span class="keyword">long</span> C[][<span class="number">2048</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="matrix-c-1"><a href="#matrix-c-1" class="headerlink" title="matrix.c"></a>matrix.c</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include "matrix.h"</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define LOOP_UNROLL 8</span><br><span class="line">#define MAXTHREAD 8</span><br><span class="line">#define MAXN 2048</span><br><span class="line">typedef struct Argu &#123;</span><br><span class="line">    int l, r, N;</span><br><span class="line">    UINT *A, *B, *C;</span><br><span class="line">&#125; Argu;</span><br><span class="line">static void transpose(int N, UINT A[][2048]) &#123;</span><br><span class="line">    UINT t;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for (int j = i+1; j &lt; N; j++)</span><br><span class="line">                t = A[i][j], A[i][j] = A[j][i], A[j][i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void* thread_multiply(void *arg) &#123;</span><br><span class="line">    Argu data = * ((Argu *) arg);</span><br><span class="line">    int l = data.l, r = data.r;</span><br><span class="line">    int N = data.N;</span><br><span class="line">    UINT *A = data.A, *B = data.B, *C = data.C;</span><br><span class="line">    UINT stkA[MAXN];</span><br><span class="line">    for (int i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        memcpy(stkA, A + (i * MAXN), sizeof(UINT) * N);</span><br><span class="line">        for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            UINT sum = 0;</span><br><span class="line">//            UINT *a = A + (i * MAXN), *b = B + (j *  MAXN);</span><br><span class="line">            UINT *a = stkA, *b = B + (j * MAXN);</span><br><span class="line">            int k;</span><br><span class="line">            for (k = 0; k+LOOP_UNROLL &lt; N; k += LOOP_UNROLL) &#123;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (; k &lt; N; k++)</span><br><span class="line">                sum += *a * *b, a++, b++;</span><br><span class="line">            *(C + (i * MAXN + j)) = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">void multiply(int N, UINT A[][2048], UINT B[][2048], UINT C[][2048]) &#123;</span><br><span class="line">    transpose(N, B);</span><br><span class="line"> </span><br><span class="line">    pthread_t *threads;</span><br><span class="line">    threads = (pthread_t *) malloc(MAXTHREAD * sizeof(pthread_t));</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; MAXTHREAD; i++) &#123;</span><br><span class="line">        Argu *data = (Argu *) malloc(sizeof(Argu));</span><br><span class="line">        data-&gt;l = i * N / MAXTHREAD;</span><br><span class="line">        data-&gt;r = (i+1) * N / MAXTHREAD - 1;</span><br><span class="line">        data-&gt;N = N;</span><br><span class="line">        data-&gt;A = &amp;A[0][0], data-&gt;B = &amp;B[0][0], data-&gt;C = &amp;C[0][0];</span><br><span class="line">        pthread_create(&amp;threads[i], NULL, thread_multiply, (void *) (data));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; MAXTHREAD; i++) </span><br><span class="line">        pthread_join(threads[i], NULL);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-jg-10086" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/20/jg-10086/" class="article-date">
  <time datetime="2016-04-20T05:26:20.000Z" itemprop="datePublished">2016-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/20/jg-10086/">批改娘 10086. Red/Blue Computation</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/04/20/jg-10086/" data-id="ciq8w965f004i9yxcf7i4wb44" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/04/20/jg-10086/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenMP/">OpenMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>模擬工作流程，在一個 <span>$N \times N$</span><!-- Has MathJax --> 的網格 (左邊界可以通到右邊界，上邊界可以通到下邊界) 上有三種狀態紅 <span>$R$</span><!-- Has MathJax -->, 藍 <span>$B$</span><!-- Has MathJax -->, 空格 <span>$W$</span><!-- Has MathJax -->，每次模擬分成兩個步驟</p>
<ul>
<li>第一步，只有紅 <span>$R$</span><!-- Has MathJax --> 可移動，紅 <span>$R$</span><!-- Has MathJax --> 只能往右移動一格到空白 <span>$W$</span><!-- Has MathJax --> 的位置，否則仍在原處。</li>
<li>第二步，只有藍 <span>$B$</span><!-- Has MathJax --> 可移動，藍 <span>$B$</span><!-- Has MathJax --> 只能往下移動一格到空白 <span>$W$</span><!-- Has MathJax --> 的位置，否則仍在原處。</li>
</ul>
<p>請問模擬 <span>$M$</span><!-- Has MathJax --> 次後盤面為何？</p>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>輸入只有一組測資，第一行有兩個整數 <span>$N, \; M$</span><!-- Has MathJax -->，分別為盤面大小以及模擬次數。接下來會有 <span>$N$</span><!-- Has MathJax --> 行，每一行上會有 <span>$N$</span><!-- Has MathJax --> 個字元。</p>
<ul>
<li><span>$1 \le N, M \le 1000$</span><!-- Has MathJax -->
</li>
</ul>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>輸出 <span>$N \times N$</span><!-- Has MathJax --> 盤面。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">RRWR</span><br><span class="line">WWBW</span><br><span class="line">BWRW</span><br><span class="line">WWWW</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RWRR</span><br><span class="line">WWWW</span><br><span class="line">WWBR</span><br><span class="line">BWWW</span><br></pre></td></tr></table></figure>
<h2 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h2><p><canvas id="canvas" width="420px" height="200px" style="background: #fff; magrin:20px;"><br>    </canvas><br>    <form name="input" action="#" id="input"><br>        <textarea rows="10" cols="60" id="inputblock">1 1 0 1<br>0 0 2 0<br>2 0 1 0<br>0 0 0 0</textarea><br>        <button type="submit" name="submit" id="submit">Run</button><br>    </form></p>
<script type="text/javascript" language="javascript">

function Simulation(h, w, board) {
    this.h = h;
    this.w = w;
    this.board = board;
    this.gap = 40;
    this.padding = 10;
    this.draw = function(canvas) {
        var context = canvas.getContext("2d");
        for (var i = 0, dx = 0; i <= this.w; i++, dx += this.gap) {
            context.moveTo(dx + this.padding, this.padding);
            context.lineTo(dx + this.padding, this.padding + this.h * this.gap);
        }
        for (var i = 0, dy = 0; i <= this.h; i++, dy += this.gap) {
            context.moveTo(this.padding, dy + this.padding);
            context.lineTo(this.w * this.gap + this.padding, dy + this.padding);
        }
        context.strokeStyle = "black";
        context.stroke();
        function drawGird(color, x, y, gap, padding) {
            var colors = ['white', 'red', 'blue'];
            var lx, ly, line = 2;
            lx = gap * x + padding + line;
            ly = gap * y + padding + line;
            context.fillStyle = colors[color];
            context.fillRect(lx, ly, 
                    gap - 2 * line, gap - 2 * line);
        }

        for (var i = 0; i < this.h; i++) {
            for (var j = 0; j < this.w; j++)
                drawGird(this.board[i][j], j, i, 
                    this.gap, this.padding);
        }
    }
    this.step = function() {
        var next;
        next = new Array();
        for (var i = 0; i < this.h; i++) {
            next[i] = new Array();
            for (var j = 0; j < this.w; j++)
                next[i][j] = 0;
        }

        // Red
        for (var i = 0; i < this.h; i++) {
            for (var j = 0; j < this.w; j++) {
                if (this.board[i][j] == 1) {
                    var pos = j+1;
                    if (pos == this.w)    pos = 0;
                    if (this.board[i][pos] == 0)
                        next[i][pos] = 1;
                    else
                        next[i][j] = 1;
                } else if (this.board[i][j] == 2) {
                    next[i][j] = this.board[i][j];
                }
            }
        }

        this.board = next;
        next = new Array();
        for (var i = 0; i < this.h; i++) {
            next[i] = new Array();
            for (var j = 0; j < this.w; j++)
                next[i][j] = 0;
        }
        // Blue
        for (var i = 0; i < this.h; i++) {
            for (var j = 0; j < this.w; j++) {
                if (this.board[i][j] == 2) {
                    var pos = i+1;
                    if (pos == this.h)    pos = 0;
                    if (this.board[pos][j] == 0)
                        next[pos][j] = 2;
                    else
                        next[i][j] = 2;
                } else if (this.board[i][j] == 1) {
                    next[i][j] = this.board[i][j];
                }
            }
        }
        this.board = next;
    }
}

var test, drawTimer;

var inputForm = document.getElementById("input");
inputForm.addEventListener("submit", function(event) {
    var text = document.getElementById("inputblock").value;
    var line = text.split('\n');
    var H = 0, W = 0;
    var board = new Array();
    for (var i in line) {
        var list = line[i].match(/\d+/g);
        W = Math.max(W, list.length);
        var numArr = new Array();
        for (var j in list)
            numArr[j] = parseInt(list[j]);
        board[H] = numArr;
        H++;
    }
    clearInterval(drawTimer);
    test = new Simulation(H, W, board);    
    test.draw(document.getElementById("canvas"));
    drawTimer = setInterval(function() {
            test.step();
            test.draw(document.getElementById("canvas"));
    }, 500);

    event.preventDefault();
});
</script>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>模擬工作流程，平行計算下一個狀態，利用兩個滾動數組的方式交替使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_WHITE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_RED   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_BLUE  2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> g1[MAXN][MAXN], g2[MAXN][MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveRed</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">memset</span>(g2[i], C_WHITE, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g1[i][j] == C_BLUE) &#123;</span><br><span class="line">                g2[i][j] = C_BLUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g1[i][j] == C_RED) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = j+<span class="number">1</span> == n ? <span class="number">0</span> : j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (g1[i][next] == C_WHITE)</span><br><span class="line">                    g2[i][next] = C_RED;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    g2[i][j] = C_RED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveBlue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">memset</span>(g1[i], C_WHITE, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g2[i][j] == C_RED) &#123;</span><br><span class="line">                g1[i][j] = C_RED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g2[i][j] == C_BLUE) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = i+<span class="number">1</span> == n ? <span class="number">0</span> : i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (g2[next][j] == C_WHITE)</span><br><span class="line">                    g1[next][j] = C_BLUE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    g1[i][j] = C_BLUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">toIndex</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'W'</span>)    <span class="keyword">return</span> C_WHITE;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'R'</span>)    <span class="keyword">return</span> C_RED;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'B'</span>)    <span class="keyword">return</span> C_BLUE;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[WARNING] %s %d\n"</span>, __FILE__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBoard</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> color[<span class="number">4</span>] = <span class="string">"WRB"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">putchar</span>(color[g1[i][j]]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;g1[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                g1[i][j] = toIndex(g1[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">0</span>; it &lt; m; it++) &#123;</span><br><span class="line">            moveRed(n);</span><br><span class="line">            moveBlue(n);</span><br><span class="line">        &#125;</span><br><span class="line">        printBoard(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">4 1</span><br><span class="line">RRWR</span><br><span class="line">WWBW</span><br><span class="line">BWRW</span><br><span class="line">WWWW</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-parallel-skill-interval-partitioning" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/23/parallel-skill-interval-partitioning/" class="article-date">
  <time datetime="2016-03-23T02:20:28.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="http://i.imgur.com/MPDeX8U.jpg" rel="gallery_ciq8w96ai008y9yxc0a2iaskf">
        <img src="http://i.imgur.com/MPDeX8U.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/parallel-skill-interval-partitioning/">數據分割 區間分塊小技巧</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/03/23/parallel-skill-interval-partitioning/" data-id="ciq8w96ai008y9yxc0a2iaskf" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/03/23/parallel-skill-interval-partitioning/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/實作技巧/">實作技巧</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/數學/">數學</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>運行平行程式之前，要將資料切成很多塊，每一塊之間獨立。從邏輯上看來有 row-based, column-based, matrix-based, tree-based 等平行方法。在許多方法中，最容易入手的就是 row-based。</p>
<p>假設有 <span>$n$</span><!-- Has MathJax --> 個元素，編號介於 <span>$[0, n-1]$</span><!-- Has MathJax --> 之間，要分成 <span>$m$</span><!-- Has MathJax --> 組。每一組得編號都要連續，以增加資料局部性 (data locality) 並且每一塊大小盡可能一樣，請問要怎麼分割才好？這樣的數學問題要做出來並不是件難事，但強迫症的人來說，在程式中零碎的判斷相當折騰。</p>
<h2 id="數學分析"><a href="#數學分析" class="headerlink" title="數學分析"></a>數學分析</h2><h3 id="直觀"><a href="#直觀" class="headerlink" title="直觀"></a>直觀</h3><p>若有 <span>$n$</span><!-- Has MathJax --> 個元素分成 <span>$m$</span><!-- Has MathJax --> 組，每一個組至少有 <span>$\lfloor n / m \rfloor$</span><!-- Has MathJax --> 個元素，其中 <span>$n \mod m$</span><!-- Has MathJax --> 組會額外多一個元素。因此，對於第 <span>$i$</span><!-- Has MathJax --> 組滿足 <span>$i &lt; n \mod m$</span><!-- Has MathJax --> 都會多一個元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method0</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">int</span> bsz = n/m, rm = n%m, sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R; i &lt; m; i++) &#123;</span><br><span class="line">        sz = bsz + (i &lt; rm);</span><br><span class="line">        R = L + sz - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, (R - L + <span class="number">1</span>));</span><br><span class="line">        L = R + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序流"><a href="#程序流" class="headerlink" title="程序流"></a>程序流</h3><p>這方式屬於懶惰程序員，根據整數的性質會得到刻度，在計算第 <span>$i$</span><!-- Has MathJax --> 個刻度採用 <span>$\lfloor \frac{in}{m} \rfloor$</span><!-- Has MathJax -->，自然而然地可以與下一個刻度形成一個區間。不幸地，若 <span>$m &gt; n$</span><!-- Has MathJax --> 時，有些刻度會重疊，導致重複計算的情況發生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L, R; i &lt; m; i++) &#123;</span><br><span class="line">        L = i*n/m, R = (i+<span class="number">1</span>)*n/m - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, (R - L + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h3><p>從《具體數學》第三章節的介紹，得到幾個簡單的數學公式</p>
<span>$$\begin{align}
n = \left \lceil \frac{n}{m} \right \rceil + \left \lceil \frac{n-1}{m} \right \rceil + \cdots + \left \lceil \frac{n-m-1}{m} \right \rceil
\end{align}$$</span><!-- Has MathJax -->
<p>第 <span>$i$</span><!-- Has MathJax --> 團 (<span>$0 \le i &lt; m$</span><!-- Has MathJax -->)，要處理 <span>$\left \lceil \frac{n-i}{m} \right \rceil$</span><!-- Has MathJax --> 個元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R, sz; i &lt; m; i++) &#123;</span><br><span class="line">        sz = (n + m-i<span class="number">-1</span>) / m;</span><br><span class="line">        R = L + sz<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, sz);</span><br><span class="line">        L = R + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h3><p>又或者使用 floor 表示法</p>
<span>$$\begin{align}
n = \left \lfloor \frac{n}{m} \right \rfloor + \left \lfloor \frac{n+1}{m} \right \rfloor + \cdots + \left \lfloor \frac{n+m-1}{m} \right \rfloor
\end{align}$$</span><!-- Has MathJax -->
<p>第 <span>$i$</span><!-- Has MathJax --> 團 (<span>$0 \le i &lt; m$</span><!-- Has MathJax -->)，要處理 <span>$\left \lceil \frac{n+i}{m} \right \rceil$</span><!-- Has MathJax --> 個元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R, sz; i &lt; m; i++) &#123;</span><br><span class="line">        sz = (n + i) / m;</span><br><span class="line">        R = L + sz<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, sz);</span><br><span class="line">        L = R + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="補充流"><a href="#補充流" class="headerlink" title="補充流"></a>補充流</h3><p>不管怎樣，前 <span>$i$</span><!-- Has MathJax --> 就拿取 <span>$\lceil \frac{n}{m} \rceil$</span><!-- Has MathJax -->，最後一組拿少一點。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">int</span> bsz = (n + m<span class="number">-1</span>)/m, sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R; i &lt; m; i++) &#123;</span><br><span class="line">        L = i*bsz, R = L + bsz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &gt;= n)	R = n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, (R - L + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method0</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">int</span> bsz = n/m, rm = n%m, sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R; i &lt; m; i++) &#123;</span><br><span class="line">        sz = bsz + (i &lt; rm);</span><br><span class="line">        R = L + sz - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, (R - L + <span class="number">1</span>));</span><br><span class="line">        L = R + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L, R; i &lt; m; i++) &#123;</span><br><span class="line">        L = i*n/m, R = (i+<span class="number">1</span>)*n/m - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, (R - L + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R, sz; i &lt; m; i++) &#123;</span><br><span class="line">        sz = (n + m-i<span class="number">-1</span>) / m;</span><br><span class="line">        R = L + sz<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, sz);</span><br><span class="line">        L = R + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R, sz; i &lt; m; i++) &#123;</span><br><span class="line">        sz = (n + i) / m;</span><br><span class="line">        R = L + sz<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, sz);</span><br><span class="line">        L = R + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In %s\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">int</span> bsz = (n + m<span class="number">-1</span>)/m, sz;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, L = <span class="number">0</span>, R; i &lt; m; i++) &#123;</span><br><span class="line">        L = i*bsz, R = L + bsz - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &gt;= n)	R = n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d len([%d, %d]) = %d\n"</span>, i, L, R, (R - L + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*FUNC[])(<span class="keyword">int</span>, <span class="keyword">int</span>) = &#123;method0, method1, method2, method3, method4&#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(FUNC)/<span class="keyword">sizeof</span>(FUNC[<span class="number">0</span>]); i++)</span><br><span class="line">            (*FUNC[i])(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-jg-10085" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/16/jg-10085/" class="article-date">
  <time datetime="2016-03-16T01:52:03.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/jg-10085/">批改娘 10085. Parallel Count (debug)</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/03/16/jg-10085/" data-id="ciq8w965c004f9yxc7arkk0l9" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/03/16/jg-10085/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>這有一份由 pthread 撰寫的序列總和計算，假設不開任何的優化參數，在快取處理會有嚴重缺失。</p>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p>輸入序列長度 <span>$n$</span><!-- Has MathJax -->，計算 <span>$m$</span><!-- Has MathJax --> 次經由 <span>$\text{key}, \; \text{key} + 1, \; \text{key} + 2, \; \cdots, \; \text{key} + m-1$</span><!-- Has MathJax --> 加密的序列總和。這部份將不提供修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m, key;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">0</span>; it &lt; m; it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = run(n, key);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, ++cases, ret);</span><br><span class="line">        key++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="utils-h"><a href="#utils-h" class="headerlink" title="utils.h"></a>utils.h</h3><p>計算工作交由 <code>void f(int n, int key, int *p1, int *p2, int *p3, int *p4);</code> 完成最後四個參數，將會由 4 個 thread 計算分別儲存在位址 <code>p1</code>, <code>p2</code>, <code>p3</code>, <code>p4</code> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __UTILS_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> key, <span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2, <span class="keyword">int</span> *p3, <span class="keyword">int</span> *p4)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="sum-c"><a href="#sum-c" class="headerlink" title="sum.c"></a>sum.c</h3><p>平行計算序列總和，特別注意到 <code>void* subtask(void* argu)</code> 中存取的記憶體位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Argu &#123;</span><br><span class="line">    <span class="keyword">int</span> *result;</span><br><span class="line">    <span class="keyword">int</span> L, R, key;</span><br><span class="line">&#125; Argu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">rotate_left</span><span class="params">(uint32_t x, uint32_t n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">encrypt</span><span class="params">(uint32_t m, uint32_t key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rotate_left(m, key&amp;<span class="number">31</span>) + key)^key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">subtask</span><span class="params">(<span class="keyword">void</span>* argu)</span> </span>&#123;</span><br><span class="line">    Argu *ptr = (Argu *) argu;</span><br><span class="line">    *(ptr-&gt;result) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ptr-&gt;L; i &lt;= ptr-&gt;R; i++)</span><br><span class="line">        *(ptr-&gt;result) += encrypt(i, ptr-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> key, <span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2, <span class="keyword">int</span> *p3, <span class="keyword">int</span> *p4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> *output[<span class="number">4</span>] = &#123;p1, p2, p3, p4&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Argu *argu = (Argu *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Argu));</span><br><span class="line">            argu-&gt;result = output[i];</span><br><span class="line">            argu-&gt;L = i * (n / <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">            argu-&gt;R = argu-&gt;L + n / <span class="number">4</span> - <span class="number">1</span>;</span><br><span class="line">            argu-&gt;key = key;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) argu-&gt;R = n;</span><br><span class="line">            pthread_create(&amp;threads[i], <span class="literal">NULL</span>, subtask, argu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="job-c"><a href="#job-c" class="headerlink" title="job.c"></a>job.c</h3><p>你的工作要改善下方代碼的效能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret[<span class="number">128</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    f(n, key, ret, ret+<span class="number">1</span>, ret+<span class="number">2</span>, ret+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        sum += ret[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>輸入只有一行三個整數 <span>$n, \; m, \; \text{key}$</span><!-- Has MathJax -->。</p>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>輸出 <span>$m$</span><!-- Has MathJax --> 序列總和結果 (無視 overflow)。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000 10 514</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1397862656</span><br><span class="line">Case #2: 1970821632</span><br><span class="line">Case #3: -1178356736</span><br><span class="line">Case #4: 1113221120</span><br><span class="line">Case #5: 1401409536</span><br><span class="line">Case #6: 1977786368</span><br><span class="line">Case #7: -1164427264</span><br><span class="line">Case #8: 1145914243</span><br><span class="line">Case #9: 645957382</span><br><span class="line">Case #10: 1308383748</span><br></pre></td></tr></table></figure>
<h2 id="編譯環境"><a href="#編譯環境" class="headerlink" title="編譯環境"></a>編譯環境</h2><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFLAG=-std=c99 -pthread</span><br><span class="line"></span><br><span class="line">all: main.c sum.c job.c</span><br><span class="line">    gcc $(CFLAG) main.c -c</span><br><span class="line">    gcc $(CFLAG) sum.c -c</span><br><span class="line">    gcc $(CFLAG) main.o sum.o job.c -o job</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/joaquintides/usingstdcpp2015/blob/master/Mind%20the%20cache.pdf" target="_blank" rel="external">reference</a></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由於茵可大神給予我參考的簡報 <a href="https://github.com/joaquintides/usingstdcpp2015/blob/master/Mind%20the%20cache.pdf" target="_blank" rel="external">Mind Cache</a> 中提到不少的快取實驗，其中一部份就是在 thread 使用上，於是就拿來出題測試測試一番。</p>
<p>通常講到數據局部性 (Data Locality) 都希望資料盡量集中，但一不小心會犯下錯誤，就是在多個 thread 儲存答案時，雖然不會共用同一個位址，但相鄰的位址在另一個核 (core) 使用，由於彼此之間相互修改，兩個相鄰位址若放在同一個 cache line，dirty bit 勢必要讓他們從 cache line 掉到 L1 -&gt; L2 -&gt; L3，進行資料同步。</p>
<p>目前 cache line 普遍上設計大小為 64 Bytes，相當於間隔 16 個 4 bytes Integer 的差距，所以儲存答案間隔遠一點會比近一點好。當然，編譯器優化參數開到 O2 以上時，似乎就直接先存放到暫存器裡頭，不會不斷地存取 global memory 部份，如此一來，就不會發生 cache miss 問題。實驗結果效能可以差到四倍左右。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ret[<span class="number">128</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    f(n, key, ret+<span class="number">0</span>, ret+<span class="number">16</span>, ret+<span class="number">32</span>, ret+<span class="number">48</span>);</span><br><span class="line">    sum = ret[<span class="number">0</span>] + ret[<span class="number">16</span>] + ret[<span class="number">32</span>] + ret[<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-jg-10084" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/16/jg-10084/" class="article-date">
  <time datetime="2016-03-16T01:20:59.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/平行程式/">平行程式</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/jg-10084/">批改娘 10084. Prefix Sum (pthread)</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/03/16/jg-10084/" data-id="ciq8w965200489yxcx3cs5xp9" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/03/16/jg-10084/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/批改娘/">批改娘</a></li></ul>

    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>給予序列 <span>$A \left[ 1 \cdots n \right]$</span><!-- Has MathJax -->，請計算前綴和序列 <span>$S \left[ 1 \cdots n \right]$</span><!-- Has MathJax -->，其中 $<span>$S \left[ i \right] = \sum_{k=1}^{i} A \left[ k \right]$</span><!-- Has MathJax -->$</p>
<p>為了檢測方便，移除輸入和輸出時間，序列 <span>$A$</span><!-- Has MathJax --> 由一個簡單加密 <span>$\textit{key}$</span><!-- Has MathJax --> 得到序列 $<span>$A \left[ i \right] = \textit{encrypt}(i, \textit{key})$</span><!-- Has MathJax --><span>$以及輸出部分直接呼叫$</span><!-- Has MathJax -->\textit{output}(\textit{S}, n)<span>$。注意$</span><!-- Has MathJax -->S\left[ 0 \right] = 0<span>$，儲存答案的範圍為$</span><!-- Has MathJax -->S\left[ 1 \cdots n \right]$。</p>
<h3 id="utils-h"><a href="#utils-h" class="headerlink" title="utils.h"></a>utils.h</h3><p>可以直接 <code>#include &quot;utils.h&quot;</code> 在你的程式中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UTILS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">rotate_left</span><span class="params">(uint32_t x, uint32_t n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span>-n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">encrypt</span><span class="params">(uint32_t m, uint32_t key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rotate_left(m, key&amp;<span class="number">31</span>) + key)^key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(uint32_t presum[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="prefixsum-seq-c"><a href="#prefixsum-seq-c" class="headerlink" title="prefixsum-seq.c"></a>prefixsum-seq.c</h3><p>請修改這份程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THREAD 4</span></span><br><span class="line"><span class="keyword">uint32_t</span> prefix_sum[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">uint32_t</span> key;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %"</span> PRIu32, &amp;n, &amp;key) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += encrypt(i, key);</span><br><span class="line">            prefix_sum[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        output(prefix_sum, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="secret-c-測試用"><a href="#secret-c-測試用" class="headerlink" title="secret.c (測試用)"></a>secret.c (測試用)</h3><p>實際情況會用助教寫好的平行方式進行計算且雜湊公式不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(uint32_t presum[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        hash += presum[i] * i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%"</span> PRIu32 <span class="string">"\n"</span>, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h2><p>輸入有多組測資，每組測資一行兩個整數 <span>$n$</span><!-- Has MathJax -->, <span>$\textit{key}$</span><!-- Has MathJax -->，分別為序列長度 <span>$n$</span><!-- Has MathJax -->，加密金鑰 <span>$\textit{key}$</span><!-- Has MathJax -->。</p>
<ul>
<li><span>$1 \le n \le 10^7$</span><!-- Has MathJax --></li>
<li><span>$0 \le key &lt; 2^{32}$</span><!-- Has MathJax -->
</li>
</ul>
<h2 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h2><p>對於每一組測資呼叫 <code>output(uint32_t presum[], int n)</code>，隨後會輸出一個數值。</p>
<h2 id="範例輸入"><a href="#範例輸入" class="headerlink" title="範例輸入"></a>範例輸入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">10 5</span><br></pre></td></tr></table></figure>
<h2 id="範例輸出"><a href="#範例輸出" class="headerlink" title="範例輸出"></a>範例輸出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">54560</span><br></pre></td></tr></table></figure>
<h2 id="範例解釋"><a href="#範例解釋" class="headerlink" title="範例解釋"></a>範例解釋</h2><ul>
<li><span>$(n, \textit{key})=(3, 2)$</span><!-- Has MathJax -->，得 <span>$A \left[ 1 \cdots 3\right] = \left[ 4, 8, 12  \right]$</span><!-- Has MathJax -->，<span>$S \left[ 1 \cdots 3\right] = \left[ 4, 12, 24  \right]$</span><!-- Has MathJax -->，<span>$\text{hash} = 4 + 12 \times 2 + 24 \times 3 = 100$</span><!-- Has MathJax -->
</li>
</ul>
<h2 id="編譯方式"><a href="#編譯方式" class="headerlink" title="編譯方式"></a>編譯方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -std=c99 -O2 -pthread prefixsum-seq.c secret.c -o prefixsum-seq</span><br></pre></td></tr></table></figure>
<h2 id="測試主機資訊"><a href="#測試主機資訊" class="headerlink" title="測試主機資訊"></a>測試主機資訊</h2><p>推薦使用 4 個執行緒解決此問題，平行效能接近 2 倍改進。若使用過多的執行緒，將因為要排到另一個處理器上運行而變慢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">processor   : 0</span><br><span class="line">vendor_id   : GenuineIntel</span><br><span class="line">cpu family  : 6</span><br><span class="line">model       : 62</span><br><span class="line">model name  : Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz</span><br><span class="line">stepping    : 4</span><br><span class="line">microcode   : 0x415</span><br><span class="line">cpu MHz     : 1200.000</span><br><span class="line">cache size  : 15360 KB</span><br><span class="line">physical id : 0</span><br><span class="line">siblings    : 12</span><br><span class="line">core id     : 0</span><br><span class="line">cpu cores   : 6</span><br><span class="line">apicid      : 0</span><br><span class="line">initial apicid  : 0</span><br><span class="line">fpu     : yes</span><br><span class="line">fpu_exception   : yes</span><br><span class="line">cpuid level : 13</span><br><span class="line">wp      : yes</span><br><span class="line"></span><br><span class="line">processor   : 1</span><br><span class="line">vendor_id   : GenuineIntel</span><br><span class="line">cpu family  : 6</span><br><span class="line">model       : 62</span><br><span class="line">model name  : Intel(R) Xeon(R) CPU E5-2620 v2 @ 2.10GHz</span><br><span class="line">stepping    : 4</span><br><span class="line">microcode   : 0x415</span><br><span class="line">cpu MHz     : 1200.000</span><br><span class="line">cache size  : 15360 KB</span><br><span class="line">physical id : 0</span><br><span class="line">siblings    : 12</span><br><span class="line">core id     : 1</span><br><span class="line">cpu cores   : 6</span><br><span class="line">apicid      : 2</span><br><span class="line">initial apicid  : 2</span><br><span class="line">fpu     : yes</span><br><span class="line">fpu_exception   : yes</span><br><span class="line">cpuid level : 13</span><br><span class="line">wp      : yes</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>利用 <span>$P$</span><!-- Has MathJax --> 的 thread，分開計算區間 <span>$[1, N/P], \; [N/P+1, 2N/P], \cdots$</span><!-- Has MathJax --> 的前綴和，由於前綴和只有利用加法計算，加法具有結合律，隨後傳遞前 <span>$i$</span><!-- Has MathJax --> 段的和，可以循序 <span>$\mathcal{O}(P)$</span><!-- Has MathJax --> 完成，或者利用樹形平行 (tree-based) 的方式在 <span>$\mathcal{O}(\log P)$</span><!-- Has MathJax -->，在實務上直接循序即可。</p>
<p>由於採用分治方式，需要平行兩次，時間複雜度為 <span>$\mathcal{O}(2 \frac{N}{P} + P)$</span><!-- Has MathJax -->。</p>
<ul>
<li>當 <span>$P = 3$</span><!-- Has MathJax --> 時，只獲得 1.5 倍的加速</li>
<li>當 <span>$P = 4$</span><!-- Has MathJax --> 時，獲得 2 倍加速</li>
<li>當 <span>$P &gt; 4$</span><!-- Has MathJax --> 時，要將記憶體的部分傳到另一顆 CPU 上，假設搬運時間是線性正比，計算複雜度也是線性時間，那麼搬運時間不如在同一顆 CPU 上運行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"utils.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Argu &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">uint32_t</span> *psum;</span><br><span class="line">    <span class="keyword">uint32_t</span> key;</span><br><span class="line">&#125; Argu;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">subtask1</span><span class="params">(<span class="keyword">void</span> *argu)</span> </span>&#123;</span><br><span class="line">    Argu data = *((Argu *) argu);</span><br><span class="line">    <span class="keyword">int</span> l = data.l, r = data.r;</span><br><span class="line">    <span class="keyword">uint32_t</span> *psum = data.psum; </span><br><span class="line">    <span class="keyword">uint32_t</span> sum = <span class="number">0</span>, key = data.key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) &#123;</span><br><span class="line">        sum += encrypt(i, key);</span><br><span class="line">        psum[j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(argu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">subtask2</span><span class="params">(<span class="keyword">void</span> *argu)</span> </span>&#123;</span><br><span class="line">    Argu data = *((Argu *) argu);</span><br><span class="line">    <span class="keyword">int</span> l = data.l, r = data.r;</span><br><span class="line">    <span class="keyword">uint32_t</span> *psum = data.psum; </span><br><span class="line">    <span class="keyword">uint32_t</span> base = data.key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        psum[j] += base;</span><br><span class="line">    <span class="built_in">free</span>(argu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THREAD 4</span></span><br><span class="line"><span class="keyword">uint32_t</span> prefix_sum[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">uint32_t</span> key;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %"</span> PRIu32, &amp;n, &amp;key) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> BLOCK = (n+MAX_THREAD<span class="number">-1</span>) / MAX_THREAD, m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">pthread_t</span> threads[MAX_THREAD];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ) &#123;</span><br><span class="line">            Argu *argu = (Argu *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Argu));</span><br><span class="line">            argu-&gt;l = i, argu-&gt;r = min(n, i + BLOCK - <span class="number">1</span>);</span><br><span class="line">            argu-&gt;psum = prefix_sum + i, argu-&gt;key = key;</span><br><span class="line">            i += BLOCK;</span><br><span class="line">            pthread_create(&amp;threads[m], <span class="literal">NULL</span>, subtask1, argu), m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> block_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> tmp = block_sum;</span><br><span class="line">            block_sum += prefix_sum[min(n, i+BLOCK<span class="number">-1</span>)];</span><br><span class="line">            Argu *argu = (Argu *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Argu));</span><br><span class="line">            argu-&gt;l = i, argu-&gt;r = min(n, i + BLOCK - <span class="number">1</span>);</span><br><span class="line">            argu-&gt;psum = prefix_sum + i, argu-&gt;key = tmp;</span><br><span class="line">            i += BLOCK;</span><br><span class="line">            pthread_create(&amp;threads[m], <span class="literal">NULL</span>, subtask2, argu), m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">        output(prefix_sum, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-rendering-bvh-contract-and-traversal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/21/rendering-bvh-contract-and-traversal/" class="article-date">
  <time datetime="2016-01-21T09:31:34.000Z" itemprop="datePublished">2016-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/數位影像生成/">數位影像生成</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/21/rendering-bvh-contract-and-traversal/">pbrt-v2 加速結構 BVH-contract 改寫</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/01/21/rendering-bvh-contract-and-traversal/" data-id="ciq8w96bm009z9yxc3hmvujeh" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/01/21/rendering-bvh-contract-and-traversal/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h3 id="Description-of-implementation-approach-and-comments"><a href="#Description-of-implementation-approach-and-comments" class="headerlink" title="Description of implementation approach and comments"></a>Description of implementation approach and comments</h3><p>從一般 BVH 架構中，一般都是用 full binary tree，子節點要不 0 個要不 2 個。若有 <span>$N$</span><!-- Has MathJax --> 個 primitive 物件，則表示有 <span>$N$</span><!-- Has MathJax --> 個葉節點放置這些 primitive 物件，而有 <span>$N-1$</span><!-- Has MathJax --> 個內部節點紀錄 Bounding Box 的部分。在測試交點和遍歷走訪的使用上，最慘有一半是多餘計算和走訪，而另一半屬於加速結構。</p>
<p>在論文 <a href="">Ray Specialized Contraction on Bounding Volume Hierarchies</a> 中，企圖想要利用 generic tree 取代一般使用 full binary tree 實作，在不更動 BVH 的效能下，減少運行上較沒用的內部節點，用以提升遍歷走訪效能，以及提升內存快取的效率。</p>
<p>降低內部節點步驟如下所示：</p>
<ol>
<li>利用原生方法建立 full binary tree 的 BVH (利用各種分割策略完成)</li>
<li>進行坍倒 (flatten)，將二元樹不連續的記憶體分布調整成線性分布，加速遍歷走訪的內存快取效率。</li>
<li>靜態調整成 generic tree 版本，藉由啟發式收縮 (Contract)，利用節點與其子節點的 Bounding Box 表面積比例，評估浪費的走訪節點。</li>
<li>動態調整部分，採用隨機取樣，根據取樣 ray，取樣走訪次數，將比較容易打到的節點盡可能收縮到接近根節點。</li>
</ol>
<p>若要收縮節點 <span>$N$</span><!-- Has MathJax -->，假設 Bounding box 計算交點花費為 <span>$C_B$</span><!-- Has MathJax -->，穿過節點 <span>$N$</span><!-- Has MathJax --> 的 Bounding box 射線機率 <span>$\alpha_N$</span><!-- Has MathJax -->，得到收縮前後的計算差值 <span>$\delta(N)$</span><!-- Has MathJax -->，如下所示。</p>
<span>$$\begin{align}
\delta(N) &amp;= n_{N.\text{child}} \; C_B - (\alpha_N (1+n_{N.\text{child}}) +(1 - \alpha_N)) \; C_B \\
&amp; = ((1 - \alpha_N) \; n_{N.\text{child}} - 1) \; C_B
\end{align}$$</span><!-- Has MathJax -->
<p>目標讓 <span>$\delta(N) &lt; 0$</span><!-- Has MathJax -->，得到</p>
<span>$\alpha(N) &gt; 1 - \frac{1}{n_{N.\text{child}}}$</span><!-- Has MathJax -->
<p>計算 <span>$\delta(N)$</span><!-- Has MathJax --> 顯得要有效率，但又沒辦法全局考量，需要提供一個猜測算法，藉由部分取樣以及步驟 2. 的表面積總和比例進行收縮。</p>
<h3 id="實作部分"><a href="#實作部分" class="headerlink" title="實作部分"></a>實作部分</h3><p>從實作中，在步驟 2. 約略可以減少 <span>$25\%$</span><!-- Has MathJax --> 的節點，在記憶體方面的影響量沒有太大影響，節點紀錄資訊也增加 (<code>sizeof(struct Node)</code> 相對地大上許多)。</p>
<p>在步驟 3. 中，根據 pbrt-v2 的架構，加速結構能取得的場景資訊並不容易竄改，大部分的類別函數都是 <code>const function()</code>，意即無法變動 object member 的值，但針對指向位址的值可以改變。這類寫法，猜想所有加速結構都是靜態決定，在多核心運行時較不會存在同步 overhead 的影響。</p>
<p>在此，換成另外一種修改方案，在 <code>pbrt-v2/core/scene.h</code> 的 <code>bool Scene::Intersect(...)</code> 函數中加入 <code>aggregate-&gt;tick();</code>。利用 <code>aggregate-&gt;tick();</code> 這個函數，大部分呼叫都沒有更動樹狀結構。當呼叫次數 <span>$T$</span><!-- Has MathJax --> 達到一定次數時，加速結構會進行大規模的結構調整。</p>
<p>根據 pbrt rendering 的步驟，儘管不斷地測試或者是估計 <span>$T$</span><!-- Has MathJax --> 要設定的值，都無法接近全局的取樣評估，其中最大的原因是取樣順序和局部取樣調整，從理論上得知不可能會有比較好的結果。這樣的寫法提供簡便的方案去統計 pbrt 運算時較有可能的 ray 從哪裡射出，不用挖掘所有的不同類型 ray 進行取樣。</p>
<p>最後，修改檔案如下：</p>
<h4 id="修改檔案清單"><a href="#修改檔案清單" class="headerlink" title="修改檔案清單"></a>修改檔案清單</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── accelerators</span><br><span class="line">│   ├── bvhcontract.cpp</span><br><span class="line">│   └── bvhcontract.h</span><br><span class="line">└── core</span><br><span class="line">    ├── api.cpp</span><br><span class="line">    ├── primitive.cpp</span><br><span class="line">    ├── primitive.h</span><br><span class="line">    └── scene.h</span><br></pre></td></tr></table></figure>
<h4 id="core-api-cpp"><a href="#core-api-cpp" class="headerlink" title="core/api.cpp"></a><code>core/api.cpp</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Primitive *<span class="title">MakeAccelerator</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Reference&lt;Primitive&gt; &gt; &amp;prims,</span><br><span class="line">                           <span class="keyword">const</span> ParamSet &amp;paramSet)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"bvhcontract"</span>)</span><br><span class="line">        accel = CreateBVHContractAccelerator(prims, paramSet);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="core-primitive-h"><a href="#core-primitive-h" class="headerlink" title="core/primitive.h"></a><code>core/primitive.h</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Primitive : <span class="keyword">public</span> ReferenceCounted &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// MORRIS ADD</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="core-scene-h"><a href="#core-scene-h" class="headerlink" title="core/scene.h"></a><code>core/scene.h</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Scene &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Scene Public Methods</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Intersect</span><span class="params">(<span class="keyword">const</span> Ray &amp;ray, Intersection *isect)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        aggregate-&gt;tick();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Generic-Tree-設計與走訪測試"><a href="#Generic-Tree-設計與走訪測試" class="headerlink" title="Generic Tree 設計與走訪測試"></a>Generic Tree 設計與走訪測試</h3><p>在 Full binary tree style - BVH 實作中，利用前序走訪分配節點編號範圍 <span>$[0, 2N-1]$</span><!-- Has MathJax -->，因此節點編號 <span>$u$</span><!-- Has MathJax --> 的左子樹的編號為 <span>$u+1$</span><!-- Has MathJax -->，只需要紀錄右子樹編號 <code>secondChildOffset</code>，這種寫法在空間和走訪時的快取都有效能改善。在標準程序中也單用迭代方式即可完成，不採用遞迴走訪，減少 push stack 的指令。</p>
<p>在 Generic tree 版本中，基礎節點紀錄架構如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> LinearTreeNode &#123;</span><br><span class="line">    <span class="comment">// node link information</span></span><br><span class="line">    <span class="keyword">uint32_t</span> parentOffset;</span><br><span class="line">    <span class="keyword">uint32_t</span> childOffsetHead, childOffsetTail;</span><br><span class="line">    <span class="keyword">uint32_t</span> siblingOffsetNext, siblingOffsetPrev;</span><br><span class="line">    <span class="comment">// faster record</span></span><br><span class="line">    <span class="keyword">uint32_t</span> numChild;</span><br><span class="line">    <span class="comment">// node data</span></span><br><span class="line">    TreeData e;</span><br><span class="line">    <span class="keyword">uint32_t</span> visitCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在原生 BVH 求交點寫法中，根據節點的 Split-Axis 以及 Ray 的方向決定先左子樹還是先右子樹走訪，藉以獲得較高的剪枝機率。但全部先左子樹走訪的快取優勢比較高 (因為前序分配節點編號)，反之在 Split-Axis 有一半的機率走會走快取優勢不高的情況，在權衡兩者之間。</p>
<p>然而在 Generic Tree 實作上，若要提供 Split-Axis 則需要提供 <code>childOffsetTail</code> 和 <code>siblingOffsetPrev</code> 兩個指針，則多了兩個紀錄欄位，單一節點大小從 <code>sizeof(LinearBVHNode) = 32</code>拓展到 <code>sizeof(LinearBVHContractNode) = 60</code>，記憶體用量整整接近兩倍。從 Contract 算法中，節點個數保證無法減少一半，推論得到在 Contract 後記憶體用量會多一些。</p>
<p>走訪實作上分成遞迴和迭代兩種版本，遞迴在效能上會卡在 push esp, argument 等資訊上，而在迭代版本省了 call function overhead 和空間使用，但增加計算次數。而在我撰寫的版本中，還必須 access 父節點的資訊決定要往 <code>siblingOffsetNext</code> 還是 <code>siblingOffsetprev</code>，因此快取效能從理論上嚴重下滑。</p>
<p>遞迴和迭代走訪寫法如下：</p>
<h4 id="遞迴版本走訪"><a href="#遞迴版本走訪" class="headerlink" title="遞迴版本走訪"></a>遞迴版本走訪</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveTraverse</span><span class="params">(LinearTreeNode *node, LinearTreeNode *_mem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// proess</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = node-&gt;childOffsetHead;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LinearTreeNode *u; offset != <span class="number">-1</span>; offset = u-&gt;siblingOffsetNext) &#123;</span><br><span class="line">        u = &amp;_mem[offset];</span><br><span class="line">        recursiveTraverse(u, _mem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代版本走訪"><a href="#迭代版本走訪" class="headerlink" title="迭代版本走訪"></a>迭代版本走訪</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iteratorTraverse</span><span class="params">(uint32_t offset, LinearTreeNode *_mem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> process = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (offset != <span class="number">-1</span>) &#123;</span><br><span class="line">        LinearTreeNode *node = &amp;_mem[offset];</span><br><span class="line">        <span class="keyword">if</span> (process) &#123;</span><br><span class="line">            <span class="comment">// process</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;childOffsetHead != <span class="number">-1</span> &amp;&amp; process) &#123;</span><br><span class="line">            offset = node-&gt;childOffsetHead;</span><br><span class="line">            process = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;siblingOffsetNext != <span class="number">-1</span>) &#123;</span><br><span class="line">            offset = node-&gt;siblingOffsetNext;</span><br><span class="line">            process = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offset = node-&gt;parentOffset;</span><br><span class="line">            process = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="節點大小對走訪效能影響"><a href="#節點大小對走訪效能影響" class="headerlink" title="節點大小對走訪效能影響"></a>節點大小對走訪效能影響</h4><p>從實驗數據看來，遞迴版本比迭代版本在越大節點情況效能普遍性地好，預估是在遞迴版本造成的快取效能好上許多。</p>
<table>
<thead>
<tr>
<th>sizeof(LinearTreeNode) bytes \ Traversal</th>
<th>Recursive</th>
<th>Loop</th>
</tr>
</thead>
<tbody>
<tr>
<td>32</td>
<td>6.049s</td>
<td>5.628s</td>
</tr>
<tr>
<td>44</td>
<td>6.651s</td>
<td>6.817s</td>
</tr>
<tr>
<td>60</td>
<td>7.460s</td>
<td>6.888s</td>
</tr>
<tr>
<td>92</td>
<td>9.361s</td>
<td>9.271s</td>
</tr>
<tr>
<td>156</td>
<td>16.844s</td>
<td>16.694s</td>
</tr>
<tr>
<td>220</td>
<td>25.294s</td>
<td>27.031s</td>
</tr>
<tr>
<td>284</td>
<td>28.181s</td>
<td>30.900s</td>
</tr>
<tr>
<td>540</td>
<td>28.560s</td>
<td>33.707s</td>
</tr>
</tbody>
</table>
<h3 id="實驗結果"><a href="#實驗結果" class="headerlink" title="實驗結果"></a>實驗結果</h3><p>由於 <code>tick()</code> 效果並不好，調整參數後與原生的作法差距仍然存在，單靠表面積提供的啟發式收縮，效率比加上動態結果還好。但從實驗結果中得知，實作方面存在一些尚未排除的效能障礙，在多核心部分效能差距就非常明顯，預計是在求交點時同步資料造成的 overhead 時間。</p>
<p>而在減少的節點數量，光是啟發是的表面收縮就減少 <span>$25\%$</span><!-- Has MathJax --> 節點量，而在動態收縮處理，儘管已經探訪 <span>$10^7$</span><!-- Has MathJax --> 收縮點數量近乎微乎其微 (不到一兩百個節點)。</p>
<table>
<thead>
<tr>
<th>sences \ BVH policy</th>
<th>Native</th>
<th>Contract(loop)</th>
<th>Contract(recursive)</th>
<th>Node Reduce</th>
</tr>
</thead>
<tbody>
<tr>
<td>sibenik.pbrt</td>
<td>7.000s</td>
<td>10.502s</td>
<td>9.411s</td>
<td>99576 / 131457</td>
</tr>
<tr>
<td>yeahright.pbrt</td>
<td>12.297s</td>
<td>14.638s</td>
<td>14.210s</td>
<td>288707 / 376317</td>
</tr>
<tr>
<td>sponza-fog.pbrt</td>
<td>16m36.037s</td>
<td>21m09.960s</td>
<td>20m12.012s</td>
<td>91412 / 121155</td>
</tr>
</tbody>
</table>
<h3 id="Test-sences"><a href="#Test-sences" class="headerlink" title="Test sences"></a>Test sences</h3><ul>
<li><a href="http://www.pbrt.org/scenes.php" target="_blank" rel="external">pbrt.org scenes</a></li>
</ul>
<h3 id="Reference-paper"><a href="#Reference-paper" class="headerlink" title="Reference paper"></a>Reference paper</h3><p><a href="http://www.cs.cmu.edu/~ygu1/paper/PG15/conference.pdf" target="_blank" rel="external">Ray Specialized Contraction on Bounding Volume Hierarchies, Yan Gu Yong He Guy E. Blelloch</a></p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
    <article id="post-rendering-environment-lights" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/21/rendering-environment-lights/" class="article-date">
  <time datetime="2016-01-21T09:06:48.000Z" itemprop="datePublished">2016-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/學校課程/">學校課程</a>►<a class="article-category-link" href="/categories/學校課程/數位影像生成/">數位影像生成</a>
  </div>

  </div>
  <div class="article-inner ">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/21/rendering-environment-lights/">pbrt-v2 加速結構 Environment Lights 改寫</a>
    </h1>
  

      </header>
        
    <footer class="article-footer">
      <a data-url="http://morris821028.github.io/2016/01/21/rendering-environment-lights/" data-id="ciq8w96bp00a39yxc71qq1c80" class="article-share-link">Share</a>
      
        <a href="http://morris821028.github.io/2016/01/21/rendering-environment-lights/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
    <div class="article-entry article-index" itemprop="articleBody">
      
          
        
          <div class="toggle-content">
            <h3 id="Median-Cut-Algorithm"><a href="#Median-Cut-Algorithm" class="headerlink" title="Median Cut Algorithm"></a>Median Cut Algorithm</h3><p>根據論文 <a href="http://dl.acm.org/citation.cfm?id=1187029" target="_blank" rel="external">P. Debevec, A Median Cut Algorithm for Light Probe Sampling, SIGGRAPH 2006 Sketches and Applications.</a> 中，預期要將 <code>pbrt/lights/infinite.cpp</code> 中的 <code>class InfiniteAreaLight</code> 用數個點光源取代 Infinite Area Light 的寫法，提升均勻取樣的效能，而 Median Cut Algorithm 在預處理非常快，根據用多少量的點光源將影響品質，若在品質不用太好的 rendering 環境下，這是一個不錯的降質提升速度的方案。</p>
<h4 id="在-Median-Cut-Algorithm-取樣-64-equal-energy-region-的速度在不同取樣個數差異比較"><a href="#在-Median-Cut-Algorithm-取樣-64-equal-energy-region-的速度在不同取樣個數差異比較" class="headerlink" title="在 Median Cut Algorithm 取樣 64 equal-energy region 的速度在不同取樣個數差異比較"></a>在 Median Cut Algorithm 取樣 64 equal-energy region 的速度在不同取樣個數差異比較</h4><h5> Env-Light.pbrt </h5>

<div style="padding: 10px;"><br>  <div id="run-result" style="height: 480px; "><br>  </div><br></div>

<h5> Env-Light-new.pbrt </h5>

<div style="padding: 10px;"><br>  <div id="run-result-new" style="height: 480px;"><br>  </div><br></div>

<h4 id="在-Median-Cut-Algorithm-不同數量-equal-energy-region-在-256-samples-速度"><a href="#在-Median-Cut-Algorithm-不同數量-equal-energy-region-在-256-samples-速度" class="headerlink" title="在 Median Cut Algorithm 不同數量 equal-energy region 在 256 samples 速度"></a>在 Median Cut Algorithm 不同數量 equal-energy region 在 256 samples 速度</h4><h5> Median Cut Algorithm equal-energy region </h5>

<div style="padding: 10px;"><br>  <div id="run-result-region" style="height: 480px; "><br>  </div><br></div>

<script>
new Morris.Line({
  element: 'run-result',
  data: [
    { y: '4', a: 7.044, b: 5.970, c: 5.995 },
    { y: '16', a: 11.570,  b: 6.847, c: 7.007 },
    { y: '64', a: 30.650,  b: 10.487, c: 10.496 },
    { y: '256', a: 106.768,  b: 25.756, c: 27.283 }
  ],
  parseTime: false,
  xkey: 'y',
  ykeys: ['a', 'b', 'c'],
  ymin: 0.0,
  ymax: 150.0,
  labels: ['InfiniteAreaLight', 'Median-Cut Centroid 1', 'Median-Cut Centroid 2']
});
new Morris.Line({
  element: 'run-result-new',
  data: [
    { y: '4', a: 9.343, b: 11.415, c: 11.390 },
    { y: '16', a: 14.695,  b: 12.682, c: 12.640 },
    { y: '64', a: 35.954,  b: 17.984, c: 17.944 },
    { y: '256', a: 121.204,  b: 39.614, c: 39.573 }
  ],
  parseTime: false,
  xkey: 'y',
  ykeys: ['a', 'b', 'c'],
  ymin: 0.0,
  ymax: 150.0,
  labels: ['InfiniteAreaLight', 'Median-Cut Centroid 1', 'Median-Cut Centroid 2']
});
new Morris.Line({
  element: 'run-result-region',
  data: [
    { y: '4', a: 26.176, b: 41.869},
    { y: '16', a: 24.804, b: 39.456},
    { y: '64', a: 25.756, b: 39.614},
    { y: '256', a: 27.181, b: 45.259 }
  ],
  parseTime: false,
  xkey: 'y',
  ykeys: ['a', 'b'],
  ymin: 20.0,
  ymax: 60.0,
  labels: ['EnvLight', 'EnvLight-new']
});
</script>

<p>算法的步驟如下：</p>
<ol>
<li>將入射光場影像 (light probe image) 切成好幾個矩形區域，每一個區域將取用一個點光源代替。將入射光場影像轉換成灰階亮度 <span>$Y$</span><!-- Has MathJax -->，如論文中所提及的方案 <span>$Y = 0.2125 R + 0.7154 G + 0.0721 B$</span><!-- Has MathJax --> 這類型的轉換。</li>
<li>對於每一個區域將會根據最長維度切割成兩個子區域。切割成兩個子區域的亮度總和越接近越好。</li>
<li>若切割區域數量不到目標的數量，則重複步驟 2。</li>
<li>最後將每一個區域算出代表的點光源，並加總區域內的亮度和，隨後取樣根據亮度和作為取樣根據 (在 <code>Spectrum MedianCutEnvironmentLight::Sample_L(const Point&amp;, float, const LightSample&amp;, float, Vector&amp;, float*, VisibilityTester*)</code> 中使用)，用每一個區域內部的 pixel 位置和亮度計算重心作為代表的點光源。</li>
</ol>
<p>算法類似於 k-d Tree，但特別的是每次選擇區域維度最長的那一段進行切割，而不是像 k-d Tree 則是採用輪替維度進行。</p>
<p>Median Cut Algorithm 需要 <span>$\mathcal{O}(HW)$</span><!-- Has MathJax --> 時間 <span>$\mathcal{O}(HW)$</span><!-- Has MathJax --> 空間來預處理亮度資訊。若要切割成 <span>$N$</span><!-- Has MathJax --> 個區域，需要 <span>$\mathcal{O}(\log N)$</span><!-- Has MathJax --> 次迭代，每一次迭代增加兩倍區域數量。將一個區域切割時，針對維度最長的那一軸二分搜尋，二分搜尋計算其中一個區域的亮度和是否是整個區域亮度的一半，由於預處理完成的表格，可以在 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 時間內計算任意平行兩軸的矩形內部元素總和。</p>
<p>維護 <code>sumTable[i][j]</code> 計算左上角 <span>$(0, 0)$</span><!-- Has MathJax --> 右下角 <span>$(i, j)$</span><!-- Has MathJax --> 的亮度和，計算任意平行兩軸矩形內部和只需要 <span>$\mathcal{O}(1)$</span><!-- Has MathJax --> 時間。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getEnergy</span><span class="params">(<span class="keyword">float</span> sumTable[], <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> e = sumTable[VERT(ru, rv)];</span><br><span class="line">    <span class="keyword">if</span> (lu)	e -= sumTable[VERT(lu<span class="number">-1</span>, rv)];</span><br><span class="line">    <span class="keyword">if</span> (lv)	e -= sumTable[VERT(ru, lv<span class="number">-1</span>)];</span><br><span class="line">    <span class="keyword">if</span> (lu &amp;&amp; lv)	e += sumTable[VERT(lu<span class="number">-1</span>, lv<span class="number">-1</span>)];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一種方案，可以從 pbrt 原生的 <code>class MIPMap</code> 取代上述寫法，<code>MIPMap</code> 的寫法採用分層式的架構，每一層將原圖長寬各縮小一半。計算某矩形元素總和時，藉由兩層的總和估計進行內插。理論上，這種寫法雖然不夠精準，但提供很好的快取優勢。</p>
</blockquote>
<h3 id="重心計算"><a href="#重心計算" class="headerlink" title="重心計算"></a>重心計算</h3><h3 id="Centroid-Formula-1"><a href="#Centroid-Formula-1" class="headerlink" title="Centroid Formula 1"></a>Centroid Formula 1</h3><p>一般重心計算採用以下公式：</p>
<span>$$X_c = \frac{\sum^{}_{(x, y) \in \mathit{region}} L_{(x, y)} \; x}{\sum^{}_{(x, y) \in \mathit{region}} L_{(x, y)}} \\
Y_c = \frac{\sum^{}_{(x, y) \in \mathit{region}} L_{(x, y)} \; y}{\sum^{}_{(x, y) \in \mathit{region}} L_{(x, y)}}$$</span><!-- Has MathJax -->
<p>經由 Median-Cut Algorithm 在 Texmap 1 運行後，代表的點光源明顯地偏離亮區，因此為了讓代表的點光源更靠近亮區，我們將其重心公式修改成 Centroid Formula 2。</p>
<h3 id="Centroid-Formula-1-1"><a href="#Centroid-Formula-1-1" class="headerlink" title="Centroid Formula 1"></a>Centroid Formula 1</h3><p>若以 <span>$\mathit{Energy} \propto L^2_{(x, y)}$</span><!-- Has MathJax -->，能量與亮度二次成正比，則計算出的重心會更靠近亮區。</p>
<span>$$X_c = \frac{\sum^{}_{(x, y) \in \mathit{region}} L^2_{(x, y)} \; x}{\sum^{}_{(x, y) \in \mathit{region}} L^2_{(x, y)}} \\
Y_c = \frac{\sum^{}_{(x, y) \in \mathit{region}} L^2_{(x, y)} \; y}{\sum^{}_{(x, y) \in \mathit{region}} L^2_{(x, y)}}$$</span><!-- Has MathJax -->
<p>比較結果如下：</p>
<p>由於 CSS 問題，詳細內容請到 <a href="http://morris821028.github.io/hw-rendering/homework3/submission/index.html">http://morris821028.github.io/hw-rendering/homework3/submission/index.html</a> 觀看。</p>

          </div>
          <div class="toggle-input article-more-link"><a>Read More +</a></div>
        
      
    </div>

  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/categories/學校課程/page/3/">&laquo; Prev</a><a class="page-number" href="/categories/學校課程/">1</a><a class="page-number" href="/categories/學校課程/page/2/">2</a><a class="page-number" href="/categories/學校課程/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/categories/學校課程/page/5/">5</a><a class="page-number" href="/categories/學校課程/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/categories/學校課程/page/11/">11</a><a class="extend next" rel="next" href="/categories/學校課程/page/5/">Next &raquo;</a>
    </nav>
  
</section>
          
            <aside id="sidebar">
  <div id="ukagaka_panel"></div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/">學校課程</a><span class="category-list-count">108</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/介面設計/">介面設計</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/作業系統/">作業系統</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/即時系統/">即時系統</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/大學專題/">大學專題</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/巨量資料/">巨量資料</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/平行程式/">平行程式</a><span class="category-list-count">38</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/敏捷方法/">敏捷方法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/數位影像生成/">數位影像生成</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/編譯器/">編譯器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/自然語言/">自然語言</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/虛擬實境/">虛擬實境</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算型智慧/">計算型智慧</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/計算幾何/">計算幾何</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/資料庫系統/">資料庫系統</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/資訊安全/">資訊安全</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/學校課程/通識課程/">通識課程</a><span class="category-list-count">14</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/手札日記/">手札日記</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/">網頁設計</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/About-This-Blog/">About This Blog</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/HTML5/">HTML5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/JQuery/">JQuery</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/網頁設計/NodeJs/">NodeJs</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/">解題區</a><span class="category-list-count">617</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/Latex/">Latex</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/出題解題/">出題解題</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-POJ/">解題區 - POJ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-UVa/">解題區 - UVa</a><span class="category-list-count">479</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-Zerojudge/">解題區 - Zerojudge</a><span class="category-list-count">76</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-其他題目/">解題區 - 其他題目</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/解題區/解題區-未解題目/">解題區 - 未解題目</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/雜言筆記/">雜言筆記</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="text" href="/2016/06/30/diary-201606-2/">
              
                <i class="icon-file-o"></i> 
              
            走在平行道路上－後篇</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/29/diary-201606/">
              
                <i class="icon-file-o"></i> 
              
            走在平行道路上－前篇</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10116/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10116. Fast Dynamic Programming Computing I (OpenMP)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10113/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10113. Longest Common Subsequence II (CUDA)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10112/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10112. Longest Common Subsequence (CUDA)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10111/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10111. Longest Common Subsequence II (OpenMP)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10110/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10110. Longest Common Subsequence (OpenMP)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10109/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10109. Sorting (CUDA)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10108/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10108. Streams and Concurrency II (CUDA)</a>
          </li>
        
          <li>
            <a class="text" href="/2016/06/28/jg-10107/">
              
                <i class="icon-file-o"></i> 
              
            批改娘 10107. Sparse Matrix Multiplication (CUDA)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">   
      	<ul>
	      <li><a href="http://mypaper.pchome.com.tw/zerojudge" target="_blank" title="Old Blog"><i class="icon-star"></i> Morris' Blog (pchome)</a></li>
	      <li><a href="http://flere114.blogspot.tw/" target="_blank" title="蘿莉勿觸"><i class="icon-googles"></i> flere's Blog</a></li>
	      <li><a href="http://dreamoon4.blogspot.tw/" target="_blank" title="夢月"><i class="icon-googles"></i> dreamoon's Blog</a></li>
	      <li><a href="http://m80126colin.github.io" target="_blank" title="許胖們"><i class="icon-github-alt"></i> m80126colin's Blog</a></li>
	      <li><a href="http://sd12582000.blogspot.tw/" target="_blank" title="妮可妮可"><i class="icon-github-alt"></i> Nico's Blog</a></li>
	      <li><a href="http://kuoe0.logdown.com/" target="_blank" title="郭至軒大神"><i class="icon-github-alt"></i> KuoE0's Dots</a></li>
	      <li><a href="http://tyan.io/" title=""><i class="icon-github-alt"></i> Tyan Blog</a></li>
    	</ul>
    </div>
</div>

  
    
<script src="/js/jquery-ui.js"></script>
<script src="/js/ukagaka/jquery.morris.ukagaka.resource.js"></script>
<script src="/js/ukagaka/typed.js"></script>
<script type="text/javascript">
  $('#ukagaka_panel').ukagaka();
</script>
  
</aside>
          
        
      </div>
      <footer id="footer">
  
  <div class="outer">    
    <div class="social-group">
      
      <a href="https://github.com/morris821028" target="_blank" title="github"><i class="icon-github"></i></a>
      
      
      <a href="https://plus.google.com/u/0/108158678174364359204" target="_blank" title="Google+"><i class="icon-google-plus-sign"></i></a>
      
      
      <a href="https://www.facebook.com/Morris1028" target="_blank" title="facebook"><i class="icon-facebook-sign"></i></a>
      
      
      <a href="http://uhunt.felix-halim.net/id/46705" target="_blank" title="uhunt" ><span class="icon-uhunt">UVa<span></a>
      
    </div>
    <div id="footer-info" class="inner">
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/morris821028/hexo-theme-landscape" target="_blank" title="landscape">landscape</a> &copy; 2016 Shiang-Yun Yang 
    </div>  

  </div>
</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link"><i class=icon-home ></i>&nbsp&nbspHome</a>
  
    <a href="/about" class="mobile-nav-link"><i class=icon-user ></i>&nbsp&nbspAbout</a>
  
    <a href="/archives" class="mobile-nav-link"><i class=icon-archive ></i>&nbsp&nbspArchives</a>
  
    <a href="/tags" class="mobile-nav-link"><i class=icon-tags ></i>&nbsp&nbspTags</a>
  
    <a href="/picture" class="mobile-nav-link"><i class=icon-camera ></i>&nbsp&nbspPictures</a>
  
    <a href="/works" class="mobile-nav-link"><i class=icon-trophy ></i>&nbsp&nbspWorks</a>
  
</nav>
    
<script>
  var disqus_shortname = 'morris1028';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/jquery.lazyload.js"></script>
<script src="/js/jquery.als-1.6.js"></script>

<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>